#ifndef __NUCLEAR_COMPOSITOR_NUCLEAR_MATH_INCLUDED__
#define __NUCLEAR_COMPOSITOR_NUCLEAR_MATH_INCLUDED__

#include "math.h"

typedef float vec3f[3];
#define X 0
#define Y 1
#define Z 2
#define VEC3F(x,y,z) (vec3f){(x), (y), (z)}
#define FORWARD VEC3F(0,1,0)
#define UP VEC3F(0,0,1)

#define V3F_setMultiply(v,c) do { \
		v[0] *= c; \
		v[1] *= c; \
		v[2] *= c; \
	} while(0);
#define V3F_multiply(v,c) (vec3f){v[0]*c, v[1]*c, v[2]*c}

#define V3F_setCross(r, u, v) do { \
	(r)[0] = (v)[1]*(v)[2]-(u)[2]*(v)[1]; \
	(r)[1] = (u)[2]*(v)[0]-(u)[0]*(v)[2]; \
	(r)[2] = (u)[0]*(v)[1]-(u)[1]*(v)[0]; } while(0)
#define V3F_cross(u, v) (vec3f){ \
	(v)[1]*(v)[2]-(u)[2]*(v)[1], \
	(u)[2]*(v)[0]-(u)[0]*(v)[2], \
	(u)[0]*(v)[1]-(u)[1]*(v)[0]  }

#define DOT(a, b) (a)[0]*(b)[0]+(a)[1]*(b)[1]+(a)[2]*(b)[2]

// Matrix
typedef float mat4f[4][4]; // [col][row]

#define M4F_setMultiply(r,a,b) do { \
		(r)[0][0] = (a)[0][0]*(b)[0][0]+(a)[1][0]*(b)[0][1]+(a)[2][0]*(b)[0][2]+(a)[3][0]*(b)[0][3]; \
		(r)[0][1] = (a)[0][1]*(b)[0][0]+(a)[1][1]*(b)[0][1]+(a)[2][1]*(b)[0][2]+(a)[3][1]*(b)[0][3]; \
		(r)[0][2] = (a)[0][2]*(b)[0][0]+(a)[1][2]*(b)[0][1]+(a)[2][2]*(b)[0][2]+(a)[3][2]*(b)[0][3]; \
		(r)[0][3] = (a)[0][3]*(b)[0][0]+(a)[1][3]*(b)[0][1]+(a)[2][3]*(b)[0][2]+(a)[3][3]*(b)[0][3]; \
		(r)[1][0] = (a)[0][0]*(b)[1][0]+(a)[1][0]*(b)[1][1]+(a)[2][0]*(b)[1][2]+(a)[3][0]*(b)[1][3]; \
		(r)[1][1] = (a)[0][1]*(b)[1][0]+(a)[1][1]*(b)[1][1]+(a)[2][1]*(b)[1][2]+(a)[3][1]*(b)[1][3]; \
		(r)[1][2] = (a)[0][2]*(b)[1][0]+(a)[1][2]*(b)[1][1]+(a)[2][2]*(b)[1][2]+(a)[3][2]*(b)[1][3]; \
		(r)[1][3] = (a)[0][3]*(b)[1][0]+(a)[1][3]*(b)[1][1]+(a)[2][3]*(b)[1][2]+(a)[3][3]*(b)[1][3]; \
		(r)[2][0] = (a)[0][0]*(b)[2][0]+(a)[1][0]*(b)[2][1]+(a)[2][0]*(b)[2][2]+(a)[3][0]*(b)[2][3]; \
		(r)[2][1] = (a)[0][1]*(b)[2][0]+(a)[1][1]*(b)[2][1]+(a)[2][1]*(b)[2][2]+(a)[3][1]*(b)[2][3]; \
		(r)[2][2] = (a)[0][2]*(b)[2][0]+(a)[1][2]*(b)[2][1]+(a)[2][2]*(b)[2][2]+(a)[3][2]*(b)[2][3]; \
		(r)[2][3] = (a)[0][3]*(b)[2][0]+(a)[1][3]*(b)[2][1]+(a)[2][3]*(b)[2][2]+(a)[3][3]*(b)[2][3]; \
		(r)[3][0] = (a)[0][0]*(b)[3][0]+(a)[1][0]*(b)[3][1]+(a)[2][0]*(b)[3][2]+(a)[3][0]*(b)[3][3]; \
		(r)[3][1] = (a)[0][1]*(b)[3][0]+(a)[1][1]*(b)[3][1]+(a)[2][1]*(b)[3][2]+(a)[3][1]*(b)[3][3]; \
		(r)[3][2] = (a)[0][2]*(b)[3][0]+(a)[1][2]*(b)[3][1]+(a)[2][2]*(b)[3][2]+(a)[3][2]*(b)[3][3]; \
		(r)[3][3] = (a)[0][3]*(b)[3][0]+(a)[1][3]*(b)[3][1]+(a)[2][3]*(b)[3][2]+(a)[3][3]*(b)[3][3]; \
	} while(0);

#define MM44_setIdentity(r) do { \
		(r)[0][0] = 1; \
		(r)[1][0] = 0; \
		(r)[2][0] = 0; \
		(r)[3][0] = 0; \
		(r)[0][1] = 0; \
		(r)[1][1] = 1; \
		(r)[2][1] = 0; \
		(r)[3][1] = 0; \
		(r)[0][2] = 0; \
		(r)[1][2] = 0; \
		(r)[2][2] = 1; \
		(r)[3][2] = 0; \
		(r)[0][3] = 0; \
		(r)[1][3] = 0; \
		(r)[2][3] = 0; \
		(r)[3][3] = 1; \
	} while(0);

#define MM44_setPerspective(r, fovy, aspect, zNear, zFar) do {\
		MM44_setIdentity(r) \
		float const tanHalfFovy##__LINE__ = tan(fovy/2.f); \
		(r)[0][0] = 1.f / ((aspect) * (tanHalfFovy)); \
		(r)[1][1] = 1.f / ((tanHalfFovy)); \
		(r)[2][3] = -1.f; \
		(r)[2][2] = -((zFar) + (zNear)) / ((zFar) - (zNear)); \
		(r)[3][2] = -(2.f * (zFar) * (zNear)) / ((zFar) - (zNear)); \
	} while(0);

#define MM44_translate(r,v) do { \
		(r)[3][0] += (r)[0][0]*(v[X]) + (r)[1][0]*(v[Y]) + (r)[2][0]*(v[Z]); \
		(r)[3][1] += (r)[0][1]*(v[X]) + (r)[1][1]*(v[Y]) + (r)[2][1]*(v[Z]); \
		(r)[3][2] += (r)[0][2]*(v[X]) + (r)[1][2]*(v[Y]) + (r)[2][2]*(v[Z]); \
		(r)[3][3] += (r)[0][3]*(v[X]) + (r)[1][3]*(v[Y]) + (r)[2][3]*(v[Z]); \
	} while(0)

#define MM44_scale(r,v) do { \
		(r)[0][0] *= v[X]; \
		(r)[0][1] *= v[X]; \
		(r)[0][2] *= v[X]; \
		(r)[0][3] *= v[X]; \
		(r)[1][0] *= v[Y]; \
		(r)[1][1] *= v[Y]; \
		(r)[1][2] *= v[Y]; \
		(r)[1][3] *= v[Y]; \
		(r)[2][0] *= v[Z]; \
		(r)[2][1] *= v[Z]; \
		(r)[2][2] *= v[Z]; \
		(r)[2][3] *= v[Z]; \
	} while(0)

#define MM44_rotate(r,a,v) do { \
		float c = cos(a); \
		float s = sin(a); \

		vec3f temp = V4F_multiply();
		

		//vec<3, T, P> temp((T(1) - c) * v);

		//mat<4, 4, T, P> Rotate(uninitialize);
		//Rotate[0][0] = c + temp[0] * v[0];
		//Rotate[0][1] = temp[0] * v[1] + s * v[2];
		//Rotate[0][2] = temp[0] * v[2] - s * v[1];

		//Rotate[1][0] = temp[1] * v[0] - s * v[2];
		//Rotate[1][1] = c + temp[1] * v[1];
		//Rotate[1][2] = temp[1] * v[2] + s * v[0];

		//Rotate[2][0] = temp[2] * v[0] + s * v[1];
		//Rotate[2][1] = temp[2] * v[1] - s * v[0];
		//Rotate[2][2] = c + temp[2] * v[2];

		//mat<4, 4, T, P> Result(uninitialize);
		//Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		//Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		//Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		//Result[3] = m[3];
	} while(0)


#endif
